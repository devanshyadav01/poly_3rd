
# Block Zardkat 🐱

# ZK CIRCUIT IMPLEMENTATION:

Creating a circuit using the circom programming language that implements the following logical gate:
![image](https://authoring.metacrafters.io/assets/cms/Assessment_b05f6ed658.png?updated_at=2023-02-24T00:00:37.278Z)

## Description

This code is written in the CIRCOM language, a domain-specific language (DSL) for writing arithmetic circuits. It defines a circuit template for checking whether c is the product of a and b. 

## Getting Started

### Executing program

To run this program, I have used online Gitpod (VS code).
Extension used for creating a new file is .circom , example: fileName.circom

### Install
`npm install`

### Compile
`npx hardhat circom` 

This will generate the **out** file with circuit intermediaries and geneate the **MultiplierVerifier.sol** contract

### Prove and Deploy
`npx hardhat run scripts/deploy.ts`

This script does 4 things  
   1. Deploys the MultiplierVerifier.sol contract
   2. Generates a proof from circuit intermediaries with `generateProof()`
   3. Generates calldata with `generateCallData()`
   4. Calls `verifyProof()` on the verifier contract with calldata

With two commands you can compile a ZKP, generate a proof, deploy a verifier, and verify the proof 🎉

## Configuration
### Directory Structure
**circuits**
```
├── multiplier
│   ├── circuit.circom
│   ├── input.json
│   └── out
│       ├── circuit.wasm
│       ├── multiplier.r1cs
│       ├── multiplier.vkey
│       └── multiplier.zkey
├── new-circuit
└── powersOfTau28_hez_final_12.ptau
```
Each new circuit lives in it's own directory. At the top level of each circuit directory lives the circom circuit and input to the circuit.
The **out** directory will be autogenerated and store the compiled outputs, keys, and proofs. The Powers of Tau file comes from the Polygon Hermez ceremony, which saves time by not needing a new ceremony. 


**contracts**
```
contracts
└── MultiplierVerifier.sol
```
Verifier contracts are autogenerated and prefixed by the circuit name, in this example **Multiplier**

## hardhat.config.ts
```
  circom: {
    // (optional) Base path for input files, defaults to `./circuits/`
    inputBasePath: "./circuits",
    // (required) The final ptau file, relative to inputBasePath, from a Phase 1 ceremony
    ptau: "powersOfTau28_hez_final_12.ptau",
    // (required) Each object in this array refers to a separate circuit
    circuits: JSON.parse(JSON.stringify(circuits))
  },
```
### circuits.config.json
circuits configuation is separated from hardhat.config.ts for **autogenerated** purposes (see next section)
```
[
  {
    "name": "multiplier",
    "protocol": "groth16",
    "circuit": "multiplier/circuit.circom",
    "input": "multiplier/input.json",
    "wasm": "multiplier/out/circuit.wasm",
    "zkey": "multiplier/out/multiplier.zkey",
    "vkey": "multiplier/out/multiplier.vkey",
    "r1cs": "multiplier/out/multiplier.r1cs",
    "beacon": "0102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f"
  }
]
```

**adding circuits**   
To add a new circuit, you can run the `newcircuit` hardhat task to autogenerate configuration and directories i.e  
```
npx hardhat newcircuit --name newcircuit
```

**determinism**
> When you recompile the same circuit using the groth16 protocol, even with no changes, this plugin will apply a new final beacon, changing all the zkey output files. This also causes your Verifier contracts to be updated.

> For development builds of groth16 circuits, we provide the --deterministic flag in order to use a NON-RANDOM and UNSECURE hardcoded entropy (0x000000 by default) which will allow you to more easily inspect and catch changes in your circuits. You can adjust this default beacon by setting the beacon property on a circuit's config in your hardhat.config.js file.

### Code Explanation 
```circom
pragma circom 2.0.0;

```

This line specifies the version of the CIRCOM language used for this code.

```circom
template CustomCircuit()

```

This defines a circuit template named "GivenCircuit." Templates are reusable circuit components that can be instantiated with specific input values.

```circom
   signal input a;
   signal input b;  
```

Signal Inputs: a and b are input signals, and they will be provided externally when the circuit is run.

```circom
   signal X;
   signal Y;

   signal output Q;
```

Signal from Gates: X and Y are intermediary signals used in the circuit.

Final Signal Output: Q is the output signal of the circuit, which represents whether c is the product of a and b.

```circom
   component andGate = AND();
   component notGate = NOT();
   component orGate = OR();
```

Component Gates: The circuit uses three component templates: andGate, notGate, and orGate. These are reusable building blocks of the circuit, implemented as separate templates.

```circom
   andGate.a <== a;
   andGate.b <== b;
   X <== andGate.out;

   notGate.in <== b;
   Y <== notGate.out;

   orGate.a <== X;
   orGate.b <== Y;
   Q <== orGate.out;
```

Circuit Logic: The circuit is constructed using gates and logic operations.

andGate computes the logical AND operation between a and b and stores the result in X.
notGate computes the logical NOT operation on b and stores the result in Y.
orGate computes the logical OR operation between X and Y and stores the result in Q.

```circom
template AND() {
    signal input a;
    signal input b;
    signal output out;

    out <== a*b;
}
```

The AND() template is a CIRCOM component that performs a logical AND operation between two input signals a and b. It outputs the result of a AND b in the out signal.

```circom
 template NOT() {
    signal input in;
    signal output out;

    out <== 1 + in - 2*in;
}
```

The NOT() template is a CIRCOM component that computes the logical NOT operation on an input signal in and outputs the negation in the out signal. The operation can be described as out = NOT(in), where out is the negation of in.

```circom
 template OR() {
    signal input a;
    signal input b;
    signal output out;

    out <== a + b - a*b;
}
```

The OR() template is a CIRCOM component that computes the logical OR operation on input signals a and b, and outputs the result in the out signal. The operation can be described as out = a OR b.

```circom
 component main = CustomCircuit();
```

The code component main = GivenCircuit(); creates a CIRCOM component named main, which corresponds to the entire circuit defined in the GivenCircuit template. The main component checks whether the signal c is the multiplication of signals a and b based on the logic defined in the GivenCircuit template.


## Authors

- [@Sain-Biswas](https://github.com/Sain-Biswas)


## License

This contract is licensed under the [MIT](https://choosealicense.com/licenses/mit/) License (refer to the SPDX license identifier at the top of the contract).

